/**
 * 多线程（Multi-Thread）
 * - 线程概念
 * - 线程的生命周期
 * - 线程的实现
 * - 线程的优先级
 * - 多线程的同步
 * - 线程组
 *
 * 线程就是程序中单独顺序的流控制。线程本身不能运行，它只能用于程序中。
 * 多线程则指的是在单个程序中可以同时运行多个不同的线程执行不同的任务。
 * 线程是程序内的顺序控制流，只能使用分配给程序的资源和环境。
 *
 * 当程序启动运行时，就自动产生一个线程，主方法main就在这个主线程上运行。
 *
 * 多线程编程的目的：最大限度地利用CPU资源。当某一线程的处理不需要占用CPU而只和I/O等资源打交道时，让需要占用CPU资源的其他线程有机会获得CPU资源。
 *
 * 一个进程可以包含一个或多个线程
 * 一个程序实现多个代码同时交替运行就需要产生多个线程
 * CPU随机的抽出时间，让我们的程序一会做这件事情，一会做另外一件事情
 *
 * 每个线程都有独立的执行路径，多线程时多任务处理的一种特殊形式。
 * 多任务处理有两种不同的类型：基于进程的和基于线程的。
 *
 * 线程与进程的区别：
 * 多个进程的内部数据和状态都是完全独立的，而多线程是共享一块内存空间和一组系统资源，有可能互相影响。
 * 线程本身的数据通常只有寄存器数据，以及一个程序执行时使用的堆栈，所以线程的切换比进程切换的负担要小。
 *
 * 多线程程序比多进程程序需要更少的管理成本。进程是重量级的任务，需要分配给它们独立的地址空间。进程间通信是昂贵和受限的。进程间的转换也是很需要花费的。
 * 线程是轻量级的选手。它们共享相同的地址空间并且共同分享同一个进程。线程间的通讯是便宜的，线程间的转换也是低成本的。
 *
 * Java多线程的优点在于取消了主循环/轮询机制。一个线程可以暂停而不影响程序的其他部分。多线程允许活的循环在每一帧间隙中沉睡一秒而不暂停整个系统。
 *
 * Java所有的类库设计都考虑到多线程。
 * 单线程系统的处理途径是使用一种叫作轮询的事件循环方法。在该模型中，单线程控制在一无线循环中运行，轮询一个事件序列来决定下一步做什么。
 * 单线程环境，当一个线程因为等待资源时阻塞（block，挂起执行），整个程序停止运行。
 *
 * Java中线程的实现是通过run方法为线程指明要完成的任务，有两种技术来为线程提供run方法：
 * - 继承Thread类并重写run方法
 * - 通过定义实现Runnable接口的类进而实现run方法。
 *
 * 每个线程都有一个优先级。优先级较高的线程优先于优先级较低的线程执行。每个线程也可以标记为守护进程，也可以不标记为守护进程。
 * 当在某个线程中运行的代码创建一个新线程对象时，新线程的优先级初始设置为创建线程的优先级，并且只有当创建线程是一个守护进程时，新线程才是守护进程。
 *
 * 线程的消亡不能通过调用一个stop()命令。而是让run()方法自然结束。
 *
 * 线程的生命周期：一个线程从创建到消亡的过程。
 *
 * 线程的生命周期可分为四个状态：
 * 1. 创建状态
 *    当用new操作符创建一个新的线程对象时，该线程处于创建状态。处于创建状态的线程只是一个空的线程对象，系统不为它分配资源。
 *
 * 2. 可运行状态
 *    执行线程的start()方法将为线程分配必须的系统资源，安排其运行，并调用线程体---run()方法，这样就使得该线程处于可运行（Runnable）状态。
 *    这一状态并不是运行中状态（Running），因为线程也许实际上并未真正运行。
 *
 * 3. 不可运行状态
 *    当发生下列事件时，处于运行状态的线程会转入到不可运行状态。
 *    - 调用了sleep()方法；
 *    - 线程调用wait方法等待特定条件的满足
 *    - 线程输入/输出阻塞
 *    返回可运行状态：
 *    - 处于睡眠状态的线程在指定的时间过去后；
 *    - 如果线程在等待某一条件，另一个对象必须通过notify()或notifyAll()方法通知等待线程条件的改变
 *    - 如果线程是因为输入/输出阻塞，等待输入/输出完成
 *
 * 4. 消亡状态
 *    当线程的run方法执行结束后，该线程自然消亡。
 *
 * 线程的优先级
 * 设置优先级是为了在多线程环境中便于系统对线程的调度，优先级高的线程将优先执行。
 * 一个线程的优先级设置遵从以下原则：
 * - 线程创建时，子继承父的优先级
 * - 线程创建后，可通过调用setPriority()方法改变优先级
 * - 线程的优先级是1-10之间的正整数
 *   1 - MIN_PRIORITY
 *   10 - MAX_PRIORITY
 *   5 - NORM_PRIORITY
 *
 * 线程的调度策略
 * 线程调度器选择优先级最高的线程运行。但是，如果发生一下情况，就会终止线程的运行：
 * - 线程体中调用了yield()方法，让出了对CPU的占用权
 * - 线程体中调用了sleep()方法，使线程进入睡眠状态
 * - 线程由于I/O操作而受阻塞
 * - 另一个更高优先级的线程出现
 * - 在支持时间片的系统中，该线程的时间片用完
 *
 * 多线程同步
 * 在线程使用一个资源时为其加锁即可。访问资源的第一个线程为其加上锁以后，其他线程便不能再使用那个资源，除非被解锁。
 *
 * Timer和TimerTask一起工作。Timer是一个用于安排一个将来执行的任务的类。被安排的任务必须是TimerTask的一个实例。因此，为了安排一个任务，首先应该创建一个TimerTask对象，
 * 然后使用Timer的一个实例安排执行它。
 * TimerTask实现了Runnable接口：因此它可以被用于创建一个执行线程。
 * TimerTask的run()是一个抽象方法，意味着它可以被覆盖。由Runnable接口定义的run()方法包含了将被执行的程序代码。因此创建一个定时器任务的最简单的办法是扩展TimerTask和重写run()
 * 一旦任务被创建，它将通过一个类型Timer的对象被安排执行。Timer的构造函数如下：
 *   - Timer()
 *   - Timer(boolean DThread)
 * 第一种形式创建一个以常规线程方式运行的Timer对象。第二种形式当DThread为true时，使用后台线程。只要剩下的程序继续运行，后台线程就会执行。
 *
 */

package com.ssy.thread;

class MyThread implements Runnable {

    private boolean flag = true;

    @Override
    public void run() {
        while(flag) {
            // ...
        }
    }

    public void stopRunning() {
        flag = false;
    }
}

class ControlThread {

    private MyThread r = new MyThread();

    private Thread t = new Thread(r);

    public void startThread() {
        t.start();
    }

    public void stopThread() {
        r.stopRunning();
    }
}